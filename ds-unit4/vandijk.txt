  PROFESSOR: We're going to talk
about inclusion-exclusion which 
 is a generalization
of what we did 
 at the end of last lecture,
which was about the sum rule. 
 Everybody's still
talking I hear. 
 Anyway, the inclusion-exclusion
principle is very important. 
 And the best way to explain
this is by using Venn diagrams. 
 So let's do this. 
 So what did we do before? 
 When we worked on
a sum rule, we saw 
 that if we count the union of
a whole collection of sets that 
 are all disjoints, then we can
just some all the cardinalities 
 of each of the members. 
 So in the case where we have
intersections-- so sets are not 
 disjoint-- well, if you just
count all the cardinalities-- 
 all of the sizes of
the sets together-- 
 you'll start to do
some double counting. 
 So with the
inclusion-exclusion principle, 
 we can actually exactly
compute the cardinality 
 of the union of sets. 
 And you will see that
this principle can 
 be used in plenty of examples,
including some of them that 
 are on the problem set. 
 So how does it work? 
 So let's set take an example
where we just have two sets 
 and they have an intersection. 
 So say this is one set which
we call M, and say here 
 is another set which
we call E. Well, they 
 have an intersection-- there's
some overlap over here. 
 So if you would
like to write out 
 the different areas
over here, what 
 they were equal to, well, this
is everything that is in M, 
 but we exclude what is in E.
So you write it M backslash E. 
 This part over here
is the intersection 
 of-- this maybe is a little
bit too small-- so this is 
 the intersection of both sets. 
 And over here we have
everything that's 
 in E but excluding what is in
M. So if you just write out 
 the cardinalities of
the different sets 
 that we're interested
in-- so we would 
 like to compute the cardinality
of the union of M and E. 
 So let's have a look
how the cardinality of M 
 itself can be computed. 
 Well, if you use the sum rule
which says that we can simply 
 add the two disjoint
sets that make up set M-- 
 we can count each of
those cardinality-- 
 so we have M consisting of this
part, which is M excluding E, 
 plus the part that is right
here which is the intersection. 
 So we use the sum
rule and conclude 
 that we have the sum
of everything that's 
 in M excluding E
plus the cardinality 
 of the intersection. 
 Now, for set E we can do
something completely similar. 
 So we will have
everything that's 
 in E excluding what
is in M. And then 
 we still have the intersection. 
 Now we are interested in the
union of the sent M and E. 
 And now we need to add
this one this one and this 
 once together. 
 So what do we see? 
 We see that this is
actually equal to everything 
 that is in M but not
in E, everything that 
 is in their intersection,
plus everything 
 that's in E but not in M. 
 So we have these equations
that we can directly derived 
 from the sum rule. 
 And, well, now we can
see here that if we 
 are going to simply add-- that's
what the sum rule would say-- 
 simply add the
cardinality of M and of E, 
 well, if we add
those two together, 
 we will count the
intersection double. 
 So we'll need to cancel that
because it's only counted once 
 in the union. 
 So if we combine those three
over here-- those three 
 equations-- then we can conclude
that this counts the set 
 M intersecting with E twice. 
 So we have that
the union is really 
 equal to the cardinality
of M plus that 
 of E minus their intersection. 
 Now we can generalize this. 
 And we will give
one more example 
 where we have three sets and it
will give the general equation. 
 So suppose you have
three sets now. 
 Like one, another one,
and another one over here. 
 So we have M, E, and,
say, the set S. Well, 
 let's have a look how many
times these different areas-- 
 they're all disjoint--
how many times they 
 are counted when me add the
three cardinalities together. 
 So we have M plus
the cardinality of E 
 plus the cardinality
of S. Well, if you 
 do that then we count
this area exactly 
 once because it's in M, this
area we count once because it's 
 in M and another time because
it's in E-- so it's twice-- 
 this particular area
is only counted once 
 in this sum over here. 
 And similarly, we have two
times over here, two times here, 
 and one times over here. 
 And this intersection
of all of the three, 
 well, it's counted when
we count elements in M 
 but also when we
count elements in E 
 and also when we
count elements in S. 
 So this is counted three times. 
 So let's have a look. 
 It seems like we want to
do exactly the same as what 
 we did before. 
 We like to subtract an
intersection of M and S. 
 That's this part. 
 It cancels the double
counting in this area, right? 
 We can subtract this
intersection such that this 
 part is cancelled. 
 The double counting
here is canceled. 
 And similarly, we
want to subtract 
 the intersection between
E and S which would 
 eliminate this double counting. 
 But now we can see that
we start to subtract 
 too much because this central
area here will be-- well, 
 it's part of each of
those intersections 
 so it's actually eliminated. 
 All of it is subtracted. 
 So let's create
the same diagram. 
 But now when we count the sum
of all those intersections-- 
 so we have the
intersection of M intersect 
 with E, the intersection
of M with S, 
 and we also want to figure
out how many times elements 
 are counted in the set
E intersects with S. 
 So let's have a look. 
 Well, this area here
is counted zero times. 
 It's not part of any
of these intersections 
 because it-- this part is
only in M and not in S or E. 
 So this is counted zero times. 
 And here we have the same. 
 Well, this part over
here is exactly once 
 in this intersection
between those two sets. 
 It's not in this one so
this is counted once. 
 So we have by symmetry
that for all the others. 
 This area, however, is in both
this intersection as well as 
 this one and also this one. 
 So it's counted three times. 
 So now we can easily start to
combine all these together. 
 And you can see, if we take
this sum and we subtract this, 
 then the middle
area is cancelled. 
 So we have to still add the
intersection of the three sets. 
 The intersection of
M, E and S together. 
 So in a formula that
would look like this. 
 So we are interested
in the union. 
 And this can now be
written as, well, 
 the sum of the cardinalities
of the individual sets. 
 And we subtract
the intersections 
 that we have up there. 
 So M intersect E
minus M intersect 
 with S and minus E
intersect with S. 
 Now we have eliminated-- if
you look at this Venn diagram 
 over here-- this
diagram over here-- 
 we've eliminated everything
that's in the middle area. 
 So we still need to add
intersection-- everything that 
 is counted in the intersection
of M, E, as well as S. 
 So we have this equation. 
 And now you can see why we call
this the inclusion-exclusion 
 principle. 
 Here we include all the
elements in M, E and S. 
 Now we have to exclude
what we counted too much. 
 So we have exclusion over here. 
 And now we, again, have
to include some stuff 
 because we excluded too much. 
 And then we keep
on going like this. 
 So, in general, we get
the following theorem 
 that says that, if you
look at the cardinalities-- 
 of the cardinality of the union
of a whole bunch of sets-- 
 say we have n sets-- then this
is actually equal to-- well, 
 we first include the sums of all
the individual cardinalities. 
 Which is from I equals 1 to n
cardinality of Ai minus-- now 
 we have to, again,
we have to eliminate 
 all the double counting-- so
we look at every pair of sets 
 indexed by i1 and i2. 
 And we look at
their intersection 
 and we take that out
using this minus sign. 
 We exclude this. 
 And we continue like this. 
 So we add now-- because
we have excluded too much, 
 we have to include
some more-- we 
 look at all triples of sets
indexed by i1, i2-- oops-- 
 and i3. 
 And now we look at the
intersection of those sets. 
 And we continue like
this all the way 
 until we look at the very last
intersection that you can have, 
 which is intersection
of all the sets. 
 And it depends on whether
n is even or add whether we 
 have to include or exclude it. 
 So we have a minus 1
to the power n plus 1. 
 And then we have the
intersection of all of these. 
 Now, we can write this out
in a more elegant formula 
 where we just put all this
what I wrote here in a sum. 
 And then it looks like this. 
 It's the sum over k
equals 1 to n minus 1 
 to the power k plus 1. 
 So depends whether
k is even or odd 
 whether we do an inclusion
or an exclusion in this sum. 
 And we look at all the subsets
that our subsets of the index 
 set 1 up to n such that the
cardinality of the set S 
 is equal to k. 
 And now we need to look at
the cardinality of all-- 
 of the intersection of all the
sets that are indexed by S. 
 So that's-- so I run-- I put i--
so do the intersection of all i 
 in S of the sets Ai. 
 So this general formula is the
inclusion-exclusion principle. 
 And this is the way
how we can think 
 about it how to derive it. 
 Of course, this is not a proof. 
 But you could do this
yourself by using induction. 
 And you can use induction on n. 
 So that's a pretty
straightforward exercise. 
 OK. 
 So let's give an example. 
 Let's do that over here. 
 You will have a problem that's
similar on the problem set. 
 And it's goes like this. 
 You would like to know how
many permutations are there 
 with a special property. 
 So how many permutations
do I have of the set 0, 
 1 all the way up to 9. 
 So all the digits. 
 And that have consecutive--
so I put this in brackets just 
 to clarify-- so consecutive
either a 4 and a 2 right next 
 to one another. 
 So remember, a permutation
is a sequence that has each 
 of those digits exactly once. 
 And I like to count
those permutations that 
 have a 4 and a 2 next to
one another in this way. 
 So we have 4, 2. 
 Or the permutation may
have a 0, 4 or a 6, 0. 
 So I'm very curious, how
many permutations do I have? 
 And I'm going to use this
principle that I just 
 described. 
 So how do we need to
go ahead with this? 
 Well, this-- so I'm interested
in the permutations that have 
 a 4 and 2 next to one another. 
 So that could be my
first set, say, M. 
 And then I have
a set that I want 
 to count that has the 0 and
the 4 next to one another. 
 That could be my
E. And the S could 
 be those permutations that
have the 6 and a 0 next to one 
 another. 
 So then I would like to
use that rule over here. 
 So I would also need to count
all the intersections and so 
 on. 
 So let's do this. 
 Let me first give an example
of such a permutation. 
 So for example, I could
have the permutation 
 that is the sequence 7,
2, 5, 6, 0, and the 4, 
 for example, 3, 5, 1 and 9. 
 So I have all the digits
that are in the-- contained 
 in the set. 
 And I see that, actually,
this particular permutation 
 has a 6 and a 0
next to one another. 
 So it's in this particular--
the set of permutations 
 that have a 6 and a 0. 
 I can also see it
has a 0 and a 4. 
 So it's also in the set of
permutations that have a 0 
 and a 4 next to one another. 
 OK. 
 So now I'm going to define
these different sets 
 and then we're going to
start counting these. 
 And this is the type
of counting that you're 
 doing in this problem set. 
 And the intuition
that you create 
 by doing that you
can use later on when 
 we study probability theory. 
 OK. 
 So let's define the set P4,
2 as all the permutations 
 that have-- so it's the set
of permutations with 4, 2. 
 And similarly, we have P0, 4
which is the same thing but now 
 with 0, 4. 
 P6, 0, the set of full
permutations with 6, 0. 
 So let's have a look at what
the sizes of an individual 
 set of permutations. 
 How can we do this? 
 So let's have a look at the
size of, say, this one, P60. 
 Well, what kind of trick can
I do in order to count this? 
 So we have learned a
few rules last time. 
 And what I would like
to do is, well, this 
 is a slightly more
complex structure, 
 so I would like to
map this to a set 
 by means of a bijection
That will be great. 
 Then to do some
kind of other sets 
 that is easy to count for me. 
 So then, by the
bijection rule, I 
 will be able to figure out what
the cardinalities of this set. 
 So the trick here is to
find such a bijection. 
 And the idea is that you could
actually treat the 6 and the 0 
 as one unique symbol. 
 So let's see how it works. 
 So what I could do is I
can have, from the set 
 of-- from P60-- so all
the permutations that 
 have 6 and a 0 next
to one another-- I 
 can find a bijection to the
permutations of the set that 
 have 6, 0 as a single symbol. 
 And then I have all the other
symbols, all the other digits. 
 So 1, 2, 3, 4, 5, 7, 8, and 0. 
 So let's have an example of--
we have one up here, actually. 
 So how would I map this? 
 This would be mapped
according to that definition. 
 To 7, 2, 5. 
 And now I combine 6 and 0 into
one symbol in my sequence. 
 And then I have the rest. 
 4, 3, 5, 1, and 9. 
 Now this is easy for
me to count, right? 
 So this is a bijection. 
 And by the bijection rule,
the cardinality of this set 
 is equal to the total number
of permutations on this set. 
 Now, this set has
exactly eight elements 
 so I know how many there are. 
 So I know that the cardinality
is equal to 8 factorial. 
 Because there are 8 factorial
permutations on sets of size 8. 
 We saw that last time. 
 So that's the trick or-- 
 AUDIENCE: Nine. 
 PROFESSOR: Oh, is it nine? 
 Oh, yeah, you're right. 
 Great. 
 So this is 9. 
 And similarly, in the same way,
we can also count these, right? 
 We can treat 0, 4 as one
symbol or 4, 2 as one symbol. 
 So I also know that the
cardinalities of these 
 are also equal to 9 factorial. 
 Now, when I use the
inclusion-exclusion principle-- 
 so now I've computed
those three, 
 essentially-- I need to
subtract their intersections. 
 So let's compute
the intersections. 
 And if you do that, we're going
to use the exact same trick. 
 So we're going to find the
bijection to permutations 
 of a set of symbols. 
 And we just have
to specify those. 
 So let's do this together
and take, for example, 
 the intersection
of P42 with P60. 
 So what kind of a
bijection could I have? 
 So it will be all-- to
all the permutations 
 on what kind of a set? 
 So I use the exact
same trick here. 
 So I'm going to treat 4 and 2
as one symbol and 6, 0 as one 
 symbol. 
 So I have 4, 2, 6, 0 and
then all the other digits. 
 So it's the 1, 3,
5, 7, 8, and 9. 
 You can count that
this number is 8. 
 So by the bijection
rule, we have 
 that the cardinality
of this intersection 
 is equal to 8 factorial. 
 And we continue
like this to compute 
 all the other intersections. 
 And they do look a little
bit different sometimes. 
 So for example, if I
have 6, 0 and P 0, 4-- 
 so let me define the permutation
first-- or the bijection first. 
 So how do we do this one? 
 Any suggestions? 
 So what kind of a set can
I find a permutation to? 
 If I look-- so over here I have
a permutation in which 6 and 0 
 are next to one another. 
 But this is also a
permutation in which 0 and 4 
 are next to one another. 
 AUDIENCE: [INAUDIBLE]. 
 PROFESSOR: Yeah, exactly. 
 So 3, 6, 0 and 4 is one
symbol because permutation 
 is right in here has a 6
and 0 next to one another. 
 And the 0 should also be next to
the 4 because it's in this set 
 as well. 
 So we know that every
permutation in here 
 has a sub sequence of 6,
0, 4 next to one another. 
 So we can treat
this as one symbol. 
 And then we have
all the other ones. 
 And again, this is--
these are 8 elements. 
 So we have that also,
for this intersection, 
 the cardinality is equal,
by the bijection rule, 
 as the total number
of permutations 
 on a set of eight elements,
which is 8 factorial. 
 So for the last one, we
also have similar-- so 
 let me see which
one I need to do. 
 So I have 4, 2 and 0, 4. 
 Well, again, I do
the same trick. 
 Now I have a symbol that has--
well, the permutation here 
 has a 0 and a 4
next to one another, 
 and the 4 is next to a 2. 
 So I treat this as one symbol. 
 So if the permutations on
the set 0, 4, 2, and then 
 1, 3, 5, 7-- oh, and 6
as well-- 8 and nine. 
 So the cardinality of this set
is also equal to 8 factorial. 
 So now we still have to look
at the intersection of all 
 of those three in order to
use the inclusion-exclusion 
 principle. 
 And, well, the same trick
can be used over here. 
 So we look at the
intersection of P60 with P04 
 and the permutations that have
4 and 2 next to one another. 
 So what does that mean? 
 It means that the
permutation that's in here 
 has a 6, 0 and then
a 4 and then a 2. 
 So these are all the
permutations with a 6, 0, 4, 
 2 next to one another. 
 And this can map
easily to the sets 
 where we treat this
as one symbol-- 6042-- 
 and then we have 1,
3, 5, 7, 8, and 9. 
 This set has seven elements, so
the intersection of these three 
 is equal to 7 factorial. 
 And now we can use the
inclusion-exclusion principle 
 using this over here. 
 And when we plug
everything in here, 
 we can see that the
intersection-- that the union-- 
 when we count the union of P60
which P04 and P42 is actually 
 equal to 9 factorial for
these, 8 factorials for those, 
 and a 7 factorial for these. 
 So it's 3 times 9 factorial
minus 3 times 8 factorial 
 plus 1 times a 7 factorial. 
 So this is how we can use
inclusion-exclusion principle. 
 So this generalized
the sum rule. 
 And now we have a
whole set of rules 
 already discussed
since last time. 
 We continue with
the bookkeeper rule. 
 You have already seen
it during recitation 
 so I will only write
it out once more. 
 And all these rules
together we will then 
 use in a set of examples. 
 So what was the bookkeeper rule? 
 We have that-- so the
bookkeeper rule is, 
 if I have distinct copies of
letters-- so distinct copies 
 of letters l1, l2,
l3 and lk, well, then 
 the number of
sequences that have 
 exactly n1 letters
of the type l1 
 and n2 letters of the type
l2 and so on, well, we 
 can count those. 
 So sequences with n1 copies
of l1 and n2 copies of l2, 
 and then we continue like this
until we have nk copies of lk. 
 Well, we can count this. 
 So these copies can
be in an arbitrary 
 order in the sequence. 
 And we saw in recitation that
this can be written as n plus 1 
 plus n2 all the way
up to nk factorial. 
 And we divide out the product
that starts with n1 factorial 
 times n2 factorial
up to nk factorial. 
 And this we also can
write as what-- well, 
 this is actually the
definition of what we call 
 the multinomial coefficient. 
 So you've already seen the
binomial coefficients, which 
 is a special case of this one. 
 So we write this as
n1 plus up to nk. 
 And then we have
n1, n2, and we just 
 repeat all of those in here. 
 If we have k equals 2, then we
get the binomial coefficient. 
 And if k equals this 2,
we also often just forget 
 about the last term. 
 So we would get
expressions that look 
 like this, which is really
equal to nk comma n minus k. 
 OK. 
 So this is some-- these
are some definitions. 
 And we can apply
this bookkeeper rule. 
 For example, last time in the
lecture we were talking about 
 the number of bit sequences
of length 16 with four 1's. 
 We wanted to count this because
we found out that if you want 
 to select 12 donuts
of five varieties, 
 we can find a mapping of
bijection towards this set 
 of bit sequences with
12 0's and four 1's. 
 So the bookkeeper rule will tell
us exactly how many there are. 
 And that's the most basic
example, essentially, 
 of this way of counting. 
 So what do we have? 
 So the number of bit sequences
of length 16 and with four 
 1's-- well, is exactly equal
to, according to this rule, 
 as length 16 and we need to
choose four 1's out of these 
16
 And it's the
binomial coefficients 
 where we choose four
out of the 16 symbols. 
 And this is equal to 16
factorial divided by 4 
 factorial times 12 factorial. 
 Now we often also denote
the following rule-- 
 we sort of identify
as a special case. 
 We say that the number of
k elements-- of k element 
 subsets-- of an n element set
is actually equal to n choose k. 
 So this is an important
rule to remember 
 which will occur many times. 
 OK. 
 A theorem that we can have
derived from all this stuff 
 is what we call the
binomial theorem. 
 So we'll quickly go over that. 
 The binomial theorem says
that, for all integers n-- 
 positive integers n-- we have
a plus b to the power n equals 
 to the sum where we
take k from 0 to n 
 and then we have the
binomial where we 
 have this expression over here. 
 We choose k out of n
and we choose, say, k 
 times b in this expression. 
 I will explain in a
moment by an example. 
 And n minus k ace. 
 And this is the theorem. 
 And I will just
give an example just 
 to show how we can
think about this. 
 So let me do that over here. 
 So if you take n
equals to 2, then we 
 can see that we get all the
combinations, essentially, 
 of a and b of length 2. 
 So you have a times a, a times
b, b times a, and b times b. 
 So what do we see? 
 We see a squared plus ab
plus ba plus b squared. 
 Now we see that these have 1
times an a and 1 times a b. 
 This one has 2 times an a
and this one has 2 times a b. 
 And this combines together
as a squared plus 2 times 
 ab plus b squared. 
 Now, if you have n equals 3--
so we have a plus b to the power 
 3-- you will get all
the different products, 
 all the different terms,
that add up to this, 
 are all the kinds of
combinations of a's and b's. 
 So for example, we have three
a's-- so 3 times a-- but it can 
 also have a squared times b
plus aba plus b a squared. 
 And those have exactly two
times an a and one times a b. 
 I can now look at
all the others-- 
 so I may have two times
the b and one times the a. 
 So what our those? 
 We have a times b squared
plus bab plus b squared a. 
 So I count these
as the same, right? 
 They each have the
same number of b's. 
 Two times the b and
one times the a. 
 And then, finally, I
have b to the power 3 
 which counts three times the b. 
 So these are all the
possible terms that I have. 
 There are eight in total. 
 One, two, three, four,
five, up to eight. 
 And that fits, right? 
 Because I can have a
choice of an a and a b. 
 And I do that three times. 
 So 2 times 2 times
2 is equal to 8. 
 So I have eight terms. 
 And I can group them together
by taking a to the power 3 
 plus 3 times a squared
b plus 3 times-- and now 
 I have b squared a-- and
finally, b to the power 3. 
 So what do we see here? 
 How many terms are their
that have exactly two times 
 an a and one times a b? 
 Well, it's like we have a
set of three elements, right? 
 Or three positions. 
 And I like two of
them to be an a. 
 So I choose two out of
those three to be an a. 
 So I use this subset rule
to count how many times I 
 see the same term back. 
 So let's write this
out so that is-- so 
 the number of terms
that have k times an a, 
 and we have, say, n
minus k times a b. 
 So how many terms do I have? 
 Well, that is the length
of-- so the number of-- oops. 
 Change that. 
 So it's the number
of length n sequences 
 that have the
following property. 
 That these have k a's
and n minus k b's. 
 And that's easy to count. 
 Which is equal to what
we have done here before. 
 We have the binomial n choose k. 
 And that, if you plug
that in over here, 
 then we get this particular sum. 
 So it is-- this is
the binomial theorem. 
 Very famous. 
 And now we're going
to use all this stuff 
 to count some poker hands. 
 So we have come to this
part of the lecture. 
 So we're going to do
a bunch of examples 
 that are similar
to some of those 
 that you will see
in the problem set. 
 And then at the end
we go and continue 
 with some-- with a
different proof technique. 
 So let's first define
a deck of cards 
 because that's what we
are going to use now. 
 So for this type of
problems, we will 
 use a deck which is
actually a set of 52 cards. 
 And a card itself
actually has a suit. 
 And the suit can
be something that 
 looks like this, which
is called spades. 
 S of spades. 
 We have another symbol
which is this, hearts. 
 And we will have clubs
and we have diamonds. 
 And besides a suit, a
card also has a value. 
 And the values are arranged from
2, 3, 4, all the way up to 10. 
 Then we have a special
symbol-- special value-- 
 which is called the Jack. 
 We've got a Queen and a
King and finally the Ace. 
 And in total, we have
13 possible values. 
 So you can see that
we have four times, 
 because of four different
suits, 4 times 13 
 is 52 different cards
and that makes up a deck. 
 So we're going to look at hands. 
 And a hand is actually
a collection-- a set 
 of five cards. 
 So it's a subset of
the deck of five cards. 
 And we do not worry
about the order 
 of the cards in your hand. 
 They can be permuted,
if you want. 
 So the order's not important. 
 So it's a subset of five cards. 
 So how many hands do I have? 
 Well, how many ways
are there to choose 
 a subset of five cards
out of a deck of 52 cards? 
 Well, we can use
a subset through 
 and we get the
binomial 52 choose 5. 
 Which is, by the way, a lot so
let me write it out as well. 
 It's about 2 and 1/2 million. 
 So we are interested
in, when we play poker-- 
 if you do that-- in
really good hands. 
 So we like four of
a kind, which means 
 that we have four cards that
actually have the same value. 
 Or we have cards
that-- hands that have 
 what we call a full house. 
 We will count those in a moment. 
 Or other kinds of combinations. 
 And the rarer the combination
is in your hand, the higher 
 or the better your hand
is, and the more likely 
 it is that you win
the poker game. 
 If you do not get left out. 
 All right. 
 So let's give an example
of a four of a kind. 
 So we're going to
compute those and we 
 will see that we need to do--
to use all the-- a combination 
 for all these rules. 
 OK. 
 So four of a kind
is the special hand 
 where we have four
of one kind of value. 
 Notice, by the way, that the
fifth card, because of this, 
 must have a different
value, right? 
 Because there are
only four cards 
 that have, say, the value eight. 
 Because there are only
four different suits. 
 So the fifth card
will ultimately 
 have a different value. 
 So as an example, we will have
the 8 of spades and then the 9 
 of diamonds and all the
other 8's-- the 8 of diamonds 
 and the 8 of hearts and,
say, the 8 of clubs. 
 And how do we count
these types of hands? 
 We're going to look
for a representation 
 of how can you represent
such hands, such objects? 
 So we have to count a
special type of object, 
 a special kind of poker hand. 
 And in order to do
that, we're going 
 to look for a way to
represent these objects 
 and in such a way that we
can count them very easily. 
 And that's really
the trick in order 
 to solve these kinds
of counting problems. 
 So the representation
that we have here is-- 
 well, we can choose--
first of all, 
 we can choose the value of the
four kinds-- of the four cards. 
 So how many choices do I have? 
 Well, I got any choice. 
 There are 13 different
values so I have 13 choices. 
 So that's easy. 
 Secondly, I can choose the
value of the extra card. 
 So how many choices
do I have here? 
 Well, the four of a kind already
eliminates one kind of value 
 completely. 
 Right? 
 So I have any of the
other values is possible. 
 Is equally likely, even. 
 So I have 12 choices. 
 And, lastly, I can represent--
I need to still represent 
 the suit of the extra card. 
 So I also want to know the
suit of the extra card. 
 And how many choices do I have? 
 Well, I can choose
any of those four. 
 So that's four. 
 So, essentially, what
we constructed here 
 is a mapping by using
this representation. 
 And the mapping tells
us-- is as follows. 
 Let's keep this up. 
 So the mapping goes from poker
hands-- from card-- from hands 
 to-- from hands with four of
a kind to this representation. 
 So let's write it out. 
 So we have four of a kind. 
 And then we have a
function-- a mapping 
 f-- that goes to
this representation. 
 We will have the first
entry-- the value 1 
 and the value 2
and then a value 3. 
 So for example, if you
take this hands of cards, 
 well, the first one, we see that
the four of a kind has value 8. 
 The value of the second card is
the 9 of the 9 diamonds cards. 
 So we have 9. 
 And finally, the suit
that I need to select for, 
 the extra card is diamonds. 
 So this is an example. 
 And now we know, because
this is a bijection, 
 we know that the number of
hands with four of a kind 
 is equal to all these
types of sequences, 
 all these types of
sequences that can-- 
 that are chosen according
to this representation. 
 Well, we have 13 choices
for the first value. 
 And given this first
value, we have 12 choices 
 for the second value. 
 And given those two, I have four
choices for the very last entry 
 in this sequence. 
 So this is the generalized
product rule that I'm using. 
 So we see that the number of
sequences is equal to 13 times 
 12 times 4. 
 Turns out this is equal to 624. 
 Well, if you divide it
over total number of cards. 
 So how did we do this? 
 This is the generalized
product rule. 
 If you divide this number
of the total number of cards 
 we could get the fraction
of one over about 4,000. 
 So it's really rare that
you get four of a kind. 
 So it's a really good hand. 
 OK. 
 Let's do a few more of these. 
 We also like to know how
many full houses there are. 
 A full house is a special hand. 
 It has three cards of one value
and two cards of another value. 
 So how many are there? 
 So again, we are going to
use the exact same principle. 
 We're going to find
a representation 
 of this type of hand. 
 So we have three cards of one
value and two cards of another. 
 So for example, we may have
the hands that contain, 
 say, three cards with value 2. 
 A 2 clubs, a 2 spades,
and also a 2 diamonds. 
 And, say, a Jack club
and a Jack of diamonds. 
 And another example could be,
say, a 5 of diamonds and a 5 
 of hearts, 5 of clubs, 7 of
hearts, and also a 7 of club. 
 So now you can see that it's
very easy to represent this. 
 Right? 
 We can start grouping
things together. 
 We can say, represent
this by first 
 taking the value of the
three cards that I have here. 
 So it's 2. 
 Then I want to indicate in a
second term in my sequence-- 
 in my representation-- which
suits did I use over here? 
 Well, I used clubs,
spades and diamonds. 
 So it's a set club,
spades and diamonds. 
 And now I also have a pair. 
 Like, two cards
with the same value. 
 What's the value? 
 It's Jack. 
 And what are the suits
associated to these? 
 Well, clubs and the diamonds. 
 So I have not yet for-- given
you the formal definition 
 of the representation,
but you can 
 see that you could do
something like this. 
 So this is often how we start
out on a piece of paper. 
 You try to do something
and hopefully it works. 
 So we have-- here we have
diamonds, hearts, and clubs. 
 And then we have--
finally we have two cards 
 with the same value 7. 
 And they have the hearts
and clubs as suits. 
 OK. 
 So the representation
is defined as follows. 
 It just started out with a first
entry in my representation. 
 And this is going to be
the value of the triple. 
 So how many choices do
we have for this value? 
 Well, I can choose any of
the 13 possible values. 
 So I have 13 choices. 
 And the second part is
the suits of the triple. 
 Well, I have to choose
a subset of the four 
 possible suits of size three. 
 So I need to have a subset
of size three out of the four 
 possible suits. 
 And that will give me the
proper representation. 
 So how many choices do I
have for such a subset? 
 Well, there's three
elements out of four. 
 So we can use the subset
rule and see that this has 
 4 choose 3 equals four choices. 
 Then the last part is
to value of the pair 
 that I have of the two cards
that are having the same value. 
 Now, how many choices
do I have here? 
 Well, I have to be a
little bit careful, though. 
 I just want to make sure that
I do the right reasoning here. 
 I know that there's still--
because I chose a triple 
 of cards of the same
value-- for example, 
 over here I chose all these
2's-- but I still have one card 
 in my deck which has a 2. 
 Actually, here I've chosen
clubs, spades and diamonds. 
 So the one that is missing
is the 2 of hearts. 
 So I could possibly
choose the 2 of hearts. 
 But wait a minute. 
 If I choose the 2 of hearts,
how can I make a pair? 
 That's not possible, right? 
 Because I've already
chosen all the other 2's 
 so there's no other 2
to match to find a pair. 
 So I actually cannot choose this
particular value of this triple 
 for the pair. 
 But all the other
values are possible. 
 So I have 12 choices. 
 One less than the one that I've
already chosen for the triple. 
 Now, and then similarly, I
can choose suits of the pair. 
 And how many choices do I have? 
 Well, look at every
possible subset 
 that I can have of size
two out of the four suits. 
 So I use the subset rule
and find that this is 4 
 choose 2 which is equal to 6. 
 So now we're going to multiply
all of these together. 
 We use the generalized
product rule again. 
 So we have found a mapping
from hands with a full house 
 to these types of
representations-- 
 to this representation. 
 And this mapping is bijective. 
 So the number of full house
is exactly equal to the number 
 of these representations. 
 And by the generalized
product rule, 
 I can choose the first entry
of such a sequence in 13 ways. 
 The second one, given the
first one, in four ways. 
 This one I can choose
in 12 ways given I've 
 already chosen my triple. 
 And so on. 
 So by the generalized
product rule, 
 I know now that the
product of those four 
 is equal to the total
number of full house hands. 
 So how much is that? 
 It's 13 times 4 choose 3
times 12 times 4 choose 2. 
 And this turns out
to be equal to 3,744. 
 Which is a factor six bigger
than a four of a kind. 
 So it's much more likely
that you get one of those. 
 And that's the reason
why four of a kind 
 has more worth-- is worth
much more than a full house. 
 So let's do another example,
a hand with two pairs, 
 and see whether we can continue
this type of reasoning. 
 It's going pretty well. 
 And maybe we can
do the same thing. 
 We'll see that, in
counting, you really 
 have to take a lot of care. 
 So maybe you can
already see what's 
 happening when I start reasoning
in the exact same way as 
 before. 
 So let me first define
what I want to count. 
 It's a hand that have
exactly two pairs. 
 So what does that mean? 
 It means that there is-- that
we have two cards of one value 
 and another two cards
of another value. 
 So let's start out as before. 
 We're going to write
out a representation 
 and see whether we
can do this properly. 
 So we're going to use
the exact same technique. 
 So first of all,
we're going to choose 
 the value of the first pair. 
 Now, how many ways
can I do this? 
 Well, I can do this in 13 ways. 
 Any possible value is possible. 
 I need to choose the
suits of the first pair. 
 And how many ways can I do this? 
 Well, I use the same
techniques as over here, 
 so it's any possible way
to choose two elements out 
 of a set of four which
represent all the suits. 
 So that's 4 choose 2. 
 Then, three, we're
going to choose 
 the value of the second pair. 
 Well, that's easy because the
second pair, by definition, 
 must have a different value
than the one in the first pair. 
 Well, I've already
chosen one value 
 so I have 12 choices left. 
 So that's no problem. 
 And now we can continue
and do the same thing. 
 So we're going to count the
number of suites that are 
 possible for the second pair. 
 And it's the same number as
we have for the first pair. 
 So we have a number of
suits of the second pair. 
 Again, we need to
choose two suits out 
 of the complete set of suits,
which has four possibilities. 
 So it's 4 choose 2. 
 And now we can have still a
choice for the last cards. 
 We have now two pairs. 
 We still have a fifth card. 
 The fifth card also has a value. 
 Actually, I did
not write it down, 
 but if we talk about
a hand with two pairs, 
 we mean two cards of one value,
two cards of another value, 
 and the fifth card-- the extra
card-- has yet another value. 
 Because otherwise you
would have a full house 
 and we have already
counted those. 
 OK. 
 So value of the extra card. 
 Well, I've chosen
already two values. 
 The one for the first pair,
the one of the second pair, 
 so there are 11 choices left. 
 And finally, I can choose
a suit of the extra card. 
 Well, I have one out of
four choices for my suit. 
 So again we can use the
generalized product rule 
 and we can say that we have
30 choices for my first entry 
 in my presentation. 
 Right? 
 For the first choice. 
 Then given the first
choice, I have 4 choose 
 2 choices for the second. 
 And then 12 choices
for the third 
 if I've already
chosen the first two. 
 And so on. 
 So I can use the
generalized product rule 
 and count these representations. 
 So the number of
representations is actually 
 equal to 13 times 4
choose 2 times 12 times 
 4 choose 2 again times
11 times 4 choose 1. 
 So is this a number of
the hands with two pairs? 
 So this seems to be
pretty reasonable. 
 But can you see something that
has happened here that we also 
 saw actually last lecture? 
 Like, do I know for sure
that the hands with two pairs 
 is-- well, that are this
number of hands with two pairs. 
 What do I need to check in order
to make sure that that is true? 
 Well, I need to make-- I
need to prove, essentially, 
 that this representation
is actually 
 bijection from the
hands with two pairs 
 to this types of sequences. 
 So is that true? 
 Or does this mapping have
a different property? 
 Any ideas? 
 Yeah? 
 Over there. 
 AUDIENCE: No. 
 PROFESSOR: No? 
 You don't want to answer? 
 OK. 
 Well, let me-- when we talked
about the chess game last time, 
 or with the rooks,
we could essentially 
 had two rooks that we
could choose and put them 
 on different positions with no
shared rows or shared columns. 
 And here we have two pairs with
no shared suit-- with no shared 
 values. 
 But what can we do? 
 We can actually interchange
the first and the second pair. 
 So as an example, we can
have two representations 
 that map to the same hand. 
 So let me give an example. 
 So for example, suppose
you choose the value 
 3 for the first
pair and then I'm 
 choosing the set diamonds and
clubs for the suits of those. 
 And say the second pair is a
queen of diamonds and hearts. 
 And finally, I have
an ace of clubs. 
 Well, this would be a
proper sequence according 
 to this representation. 
 But this maps to a
hand that does also 
 map to if we interchange the
first and the second pair. 
 We can also start off with
the queen for the first pair 
 and we have diamonds and hearts. 
 And we have three for the second
pair with diamonds and clubs. 
 And then we finally have
the fifth card which 
 is the same, the ace of clubs. 
 Now these map to
exactly the same hand. 
 We just need to change the
first and the second pair. 
 Now this is a kind of problem
or a mental sort of confusion 
 that very easily happened. 
 This is a rather easy
example where you can see it. 
 But if you do
counting, we really 
 have to take care that
we make sure that each 
 of the sequences in
this representation 
 are really represented by,
say, one hand, in this case, 
 with two pairs. 
 But how can we remedy this? 
 It turns that we can-- by
interchanging these two pairs, 
 these two sequences are
the only two sequences 
 that map to the same hand. 
 So we know that this
is not a bijection 
 but it is a 2-to-1 mapping. 
 So now we can choose-- we
can use the division rule. 
 And by the division
rule we now know 
 that the number of
hands with two pairs 
 is actually equal to this whole
thing over here divided by 2 
 because we have a
2-to-1 function. 
 Now, this is really
something that 
 is pretty disturbing
because we have 
 a near miss in our reasoning. 
 And therefore, it
is important to keep 
 in mind the following
guidelines when we do counting. 
 It's very important
to, first of all, check 
 whether it's truly a bijection. 
 And you need to know how many
sequences or maps to the same-- 
 to the same hand. 
 So the guidelines
are as follows. 
 They're pretty
straightforward actually. 
 First of all, if
we have a function 
 f that maps from A to
B, then we would really 
 like to check very carefully
whether the number-- what 
 is the number of
elements of A that are 
 mapped to each element of B? 
 So we check how many to one
of a mapping this really is. 
 And after this we will then
apply the division rule. 
 It's very important
to check this. 
 But very often, we're
making mistakes. 
 For example, right now
I'm doing some research 
 and I've been
counting something. 
 Turns out it-- if I
use a different method 
 to count the same thing
I get a different answer. 
 So I made a mistake somewhere. 
 So that's the second guideline. 
 So what you want to
do is you want to try 
 and solving a problem
in multiple ways. 
 So try solving a problem
in a different way. 
 And especially with counting
this is very helpful. 
 So this will lead
to an extra check. 
 So we will do that for
this particular example. 
 And it generally
would always like 
 to find multiple ways to
prove things, I would say, 
 because at least you want
to have multiple-- maybe not 
 a complete proof but
subparts of proofs-- 
 you may want to find different
ways why that is true. 
 So that's how I usually
do my proofing of things. 
 So let's find a second way
to count this over here, 
 to do the double check. 
 So we're going to create a
different representation that 
 should actually
lead to a bijection. 
 So I want to find a
representation that's 
 a bijection, a 1-to-1 mapping. 
 So how do we do this? 
 I can-- let me see where I am. 
 OK. 
 So what I could do
is, first of all, 
 I can choose the values
of the two pairs. 
 So in this case, I have
the values 3 and the queen. 
 So how many choices do I have? 
 Well, I can choose
two out of 13 choices. 
 Secondly, I'm going to describe
the suit of the smaller 
 pair which is uniquely defined
because they have two values. 
 One is smaller and the
suit of the smaller 
 pair I can choose by taking one
out the four-- two out of four 
 choices because I need to choose
two suits for the smaller pair. 
 For the larger
pair, I do the same. 
 And I get 4 choose 2. 
 Now, again, I have the
value of the extra card. 
 And I have 11 choices. 
 I have already chosen two so
there are 11 choices left. 
 And finally, the suit
for the extra card 
 can be done in 4 choose 1 ways. 
 So if you multiply
those together, 
 we get 13 times 12 divided by 2. 
 And then we get times 4 choose 2
times 4 choose 2 times 11 times 
 4 choose 1. 
 And we can see that
that's exactly the same 
 as this whole
product divided by 2. 
 We actually have a bijection. 
 This particular representation
is a 1-to-1 mapping. 
 So it's always good
to find a second way 
 to prove the same result. 
 OK. 
 Let me do one more. 
 Let's do that over here. 
 Just to make sure that you
really understand this stuff, 
 I'm going to count hands
that have each suit in it. 
 So I want to count the
hands with every suit. 
 So as an example, I can
have, say, the 7 of diamonds, 
 the King of clubs, the 3 of
diamonds, the Ace of hearts, 
 and the 2 of spades. 
 Why is this a proper hand? 
 Because I can see the diamonds,
the clubs, the hearts, 
 and the spades. 
 So I have a hand in which
every suit is represented. 
 So what do I do for
my representation? 
 Well, I can have the
values of each suit 
 and I assign a specific
order to those. 
 So I want to represent for
the diamonds and the clubs 
 and the heart and the spade. 
 I want to find out what
values do I really have. 
 So values of each suit in the
order D, C, hearts and spades. 
 And how many ways do I have? 
 Well, I have 13
values for the 7, 
 I have 13 values for
the King-- for this one, 
 for this value, 13 values
for that one and 13 
 values for this one. 
 So that is pretty
straightforward. 
 Now, we still have
the extra card. 
 And the extra card
has a suit which 
 I can do in four ways
because of four choices. 
 And finally, it
also has a value. 
 And the value is-- it's
actually-- so how much is this? 
 Can this be 13? 
 Are there 13 values? 
 No, not really, right? 
 Because for each possible
given suit that I've chosen, 
 I already chose a
value before when 
 I chose a value for the
suit that I did over here. 
 So for example, this
one cannot be the 7, 
 it has to be something else. 
 There are 12 choices. 
 If I would have chose
a different suit, 
 for example hearts,
then I would not 
 be able to choose the Ace
because I already have chosen 
 the Ace in the first step. 
 So I have 12 possibilities here. 
 So this is not 13. 
 You may want to
check that again. 
 So now let's give the
representation for this one. 
 So I can have diamonds, clubs--
so let's see, in the order 
 of diamonds, clubs. 
 So I have the 7,
I have a King, I 
 have for hearts I have an
Ace, for spades I have a 2. 
 Then I have the suit for the
extra card which is a diamonds. 
 And then a value which is a 3. 
 Now we are going
to check according 
 to our guidelines over here. 
 We're going to check
the number of elements 
 that are-- the number
of sequences that 
 map to the same hand over here. 
 So is this a bijection? 
 It's not, right? 
 So why is this not a bijection? 
 Well, we can also have
the following situation 
 where we swap the 3 diamonds
and the 7 diamonds around. 
 So we choose the
3 for the diamonds 
 and then we have the
King, the Ace and the 2. 
 then we have the fifth card
which is also diamonds, 
 but now it's the 7. 
 Well, this one also maps
to this particular hand. 
 So we have a 2-to-1 mapping. 
 And we conclude that the
total number of hands, 
 where every suit is represented,
is 13 to the power 4 times 
 4 times 12 by the
generalized product rule. 
 And now by the division rule,
we have to still divide by 2. 
 So that's the total number. 
 OK. 
 So now we come to
combinatorial proofs. 
 So this is a new
proof technique. 
 And what we're
going to do is we're 
 going to count a set
in two different ways. 
 And that will lead to a
combinatorial equation. 
 So the whole idea is as follows. 
 So let me give an example first. 
 So for a combinatorial
proof, for example, 
 suppose I have n
shirts and I want 
 to choose-- I want to keep k
and I want to trash n minus k. 
 So how do I count the number
of choices that I have? 
 Well, I can choose, out of n,
I can choose the k keepers. 
 But I also can count
it in a different way. 
 I can also count
this as how many ways 
 I can select the trashers. 
 So there are n minus k out of
n shirts that I will trash. 
 So there are two different
ways to count the same choices 
 that I have. 
 So we have an
equation over here. 
 And you already know this
one because by the definition 
 of the binomial
coefficient, we have 
 that this is equal to this. 
 And so it's pretty
straightforward. 
 It's equal to this
one over here. 
 But the idea is that
we're going to count 
 a set in two different ways. 
 So another example is where
we have the following. 
 We choose a team of k elements. 
 Of k elements out
of-- oh, actually, I'm 
 talking about a team. 
 I was talking about
students here. 
 Of k students. 
 Out of n students. 
 Now, how many ways
can I do this? 
 Well, n choose k, right? 
 Well, there is a way to
count this differently. 
 I could also say, well, let's
first count the total number 
 of ways in which I choose k
students that includes Bob. 
 So let's do that. 
 So Bob is one of the
students, and if I 
 count the number
of teams with Bob, 
 how many choices do I have? 
 I choose Bob. 
 I still need to choose k minus
1 students out of the remaining 
 n minus 1 students. 
 So I have taken out Bob. 
 So there are n minus
1 students left 
 and I still need to
choose k minus 1 students. 
 The other possibility is that
we have teams that-- in which 
 Bob is not represented. 
 So now we need to
choose k students out 
 off all the students minus Bob. 
 So we have n minus 1 choose k. 
 So by the sum rule, we can
just add those two together 
 and that should be equal
to all the possibilities 
 to choose team of k students. 
 So what do I see? 
 I see that n minus 1 choose k
minus 1 plus n minus 1 choose 
 k should be equal to--
well, before I counted it 
 as this-- so it should
be equal to n choose k. 
 And this is called
Pascal's Identity. 
 And the general idea is is
that we do the following. 
 So we are actually counting
a set in two different ways. 
 That's what we did so far. 
 And when you solve
these types of problems, 
 the difficulty is that you
will need to define the set S. 
 So usually you
get a problem, you 
 need to prove some
equation like this. 
 So you define a set S.
That's the hard part of it. 
 Then we are going to show
that the cardinality of S 
 is some number n,
say, in one way. 
 So we have one
method to do this. 
 By counting. 
 And we will show that S is also
equal to some other number-- 
 like, in this case,
we had one number 
 and this was my second
one-- also by counting. 
 And then we can
conclude that n-- 
 so we conclude that n equals m. 
 So we're almost done
because I'm going 
 to prove to you a very simple
equation using this technique. 
 But it is not as trivial as
the one that we saw just now. 
 What we do now is the following. 
 We want to prove a
theorem that says 
 that if a sum r is 0 all
the way up to n, then, 
 if you take the product of the
following binomial coefficients 
 n choose r times 2n
choose n minus r, 
 this is equal to 3n choose n. 
 We need to prove this. 
 So we need to find
the proper set. 
 So how can we think about it? 
 Well, the idea is
that we're probably 
 going to choose n elements
out of 3n elements. 
 We're going to do
it in a special way. 
 And so the proof
will be as follows. 
 We take S to be all the
subsets of n balls chosen 
 from a basket of n red
balls and 2n green balls. 
 And this will do the trick. 
 So how do we do this? 
 We're going to first choose
the red balls and then 
 the green balls. 
 So let's first count S
in the very easy way. 
 Well, I just choose n balls
out of a basket of 3n balls. 
 I don't care how many
green or red balls I have. 
 So I have really 3n
choose n choices. 
 This is the number of n element
subsets from a 3n element set. 
 So that's easy. 
 Now, we can also count
it in a different way. 
 We first of all wonder
about the number of subsets 
 with exactly r red balls. 
 So how many are there? 
 Well, we choose r red balls
so we have n red balls. 
 So we need to choose
r out of those. 
 Now, in total, I need
to choose n balls. 
 So I still need to choose
n minus r balls out 
 of the set of green balls. 
 I have 2n green balls. 
 I'm going to choose n minus
r green balls over here. 
 So these are the red balls
that I select and here 
 are the green balls. 
 Now we'll use the sum rule. 
 And I add all the
different possible subsets 
 with 0 red balls, with
1 red ball, 2 red balls, 
 all the way up to n red balls. 
 So essentially, I get the
sum by the sum rule of r 0 
 all the way up to n where I
count the number of subsets 
 with exactly r red balls. 
 So that means I can choose
r out of the n red balls 
 and another n minus r out of
the 2n balls-- 2n green balls. 
 So now we equate
those two together 
 and that proves the theorem. 
 So the really hard part
in this type of proofs 
 is that you need some creativity
to find and define that set S 
 and see how that would work. 
 And the way to do that usually
is to look at this equation 
 and then say, oh,
wait a minute, I'm 
 going to talk about sets because
I choose n out of 3n over here. 
 So out of 3n elements. 
 And maybe I can
divide up the sets 
 in some kind of specific choice. 
 So tomorrow during
recitation you 
 will also see
combinatorial proof. 
 Thank you. 
 
  MARTEN VAN DIJK: So
today, we're going 
 to talk about
communication networks. 
 Communication networks
is a great application 
 of graph theory. 
 So what we're going
to study is, how 
 do you route packets
through networks? 
 So you have the internet,
which is a chaotic network. 
 It's not organized. 
 We are interested in
highly structured networks 
 and you can find
them, for example, 
 in parallel computers, where
you want to route the data flow. 
 You can find them in certain
telephone switches networks 
 and so on. 
 So we are going to talk about
a few very special ones, 
 binary trees, and then
slowly we will figure out 
 what all these performance
measures really mean. 
 This one has to do with latency. 
 We have switches, their
size, the number of them, 
 congestion, and then
we will slowly get down 
 to Benes network, which is
a really beautiful network 
 with beautiful parameters. 
 And we are going to prove those. 
 So let's start off with the
first one, the complete binary 
 tree, and let me
draw it for you. 
 In this network,
we will have a root 
 and let me just draw it
first We have vertices that 
 represent here the switches. 
 So these circles-- let me
explain it over here-- actually 
 represent a switch. 
 And the idea is that these
actually direct packets 
 through the network. 
 And these packets are
fixed-size packets 
 of data, so like, I don't
know, say 4,000 bytes or bits 
 or whatever the network
wants you to comply to. 
 So these are fixed-size
pieces of data. 
 So what we want is we want to
be able from every terminal-- 
 and the terminal I will
denote by a square-- 
 from every terminal,
I want to be 
 able to reach any
other terminal. 
 So what is a terminal? 
 A terminal is like a computer
or something like that. 
 It's actually the source
and the destination of data. 
 So what we are looking
for is how can we 
 route-- how we can find
a network of switches 
 that are connected through
wires, fibers, or-- yeah? 
 What's the question? 
 AUDIENCE: Can you
move down a bit 
 the top of the-- how
it's getting cut off? 
 No, the-- 
 That one. 
 MARTEN VAN DIJK: Oh, sorry. 
 AUDIENCE: All right. 
 Thank you. 
 MARTEN VAN DIJK:
So what we want is 
 we want to route packets
that's come from any terminal 
 to any other terminal. 
 That is what our goal is
and we want to make sure 
 that that is efficient. 
 So the first one is
this binary tree. 
 And let's see how this may work. 
 We may have switches
that actually have 
 inputs coming from terminals. 
 And the switches may
also output to terminals, 
 so here at the bottom. 
 At this site, we have
a similar structure. 
 this is the root of the tree. 
 We have another
switch over here. 
 We go down, we go up here,
and once more, like this. 
 And again, we have-- oops. 
 We have input coming in
or an output coming out 
 to their respective terminals. 
 So what is happening
here is that I 
 would like to have an
input-- say input zero wants 
 to travel all the
way over to say, 
 the output that is
present over here. 
 So let me label these. 
 So we have the output zero,
input one, output one, 
 input two and output two,
input three, and output four. 
 So well, I can definitely
reach every single output 
 from any input so that's great. 
 So this looks like something
that you are familiar with, 
 right? 
 It's just a tree. 
 It's a directed
graph, but these edges 
 go in both directions, right? 
 So I have an edge that goes from
here to here and back from here 
 to here. 
 So this is the kind of
layout that you could try out 
 first to see whether
this type of network 
 would lead to good performance. 
 So let's have a look at
the different parameters 
 and see how well this behaves. 
 So here, we have
a few parameters 
 that we will be talking about. 
 So first of all, let's
talk about the latency 
 in this particular network. 
 So how are we going
to measure this? 
 Well, we're going to
look at this graph 
 and we're going to measure
it by the number of wires 
 that you need to go through
from an input to an output. 
 So let me write this down. 
 So the latency is the time
that is required for a packet 
 to travel from an
input to an output. 
 And how are we going
to measure this? 
 Well, we're just
going to measure this 
 by the number of wires
that we need to go through. 
 So this you have seen before. 
 We can measure this
by the diameter 
 of that particular graph. 
 So here, we will define
it for a network. 
 So the diameter of
a network is going 
 to be the length of the
shortest path between the input 
 and output that
are furthest apart. 
 So let's have a look
at the graph above. 
 So for example, we can clearly
see that, for example, input 
 and output-- so say,
input zero and output one 
 are connected by just going
up one step over here, 
 but just going up
from here to here. 
 Then, this switch forwards
the packet to this switch. 
 This switch reroutes it,
forwards it over here, 
 and then it goes back to
the output, output one. 
 So for example, this particular
path only has 1, 2, 3, 4 edges. 
 And what we are interested in
is sort of the worst-case time 
 that it requires to go
from an input to an output. 
 So that means that we are
interested in a diameter. 
 And a diameter is in this
case, well, the shortest path 
 that you can find from an input
to an output that are furthest 
 apart. 
 So what are those who
are furthest apart? 
 Well, of course, you would
like to go through here, right? 
 So if I connect the input
zero to say, output four, 
 I will need to go all the
way up through the route 
 down to the output. 
 And how many edges
do we see here? 
 1, 2, 3, 4, 5, 6--
so in this example, 
 we have a diameter
that is equal to six. 
 And in general, if you are
looking at n times n networks, 
 what does it mean? 
 n is the number of inputs and n
is also the number of outputs. 
 So in this case, we have
a four times-- well, 
 this is actually
three over here-- 
 we have four inputs
and four outputs. 
 So this particular example
depicted on the board 
 is a four times four network. 
 So if you generalize this
for any size binary tree, 
 say, an n times n
network, then what's 
 the diameter of such
a general network? 
 Well, if we have n
inputs and n outputs, 
 well, we have to
go all the way up 
 through towards the root
and all the way down. 
 So we actually count the
length of a leaf to the root 
 here twice. 
 So in general, we have a
diameter that looks like this. 
 It's 2 times 1 plus
the logarithm of n. 
 So in this lecture, we will have
n is going to be a power of 2, 
 just to make
calculations simple. 
 And the logarithm is
always to the base two. 
 So this is a diameter of
a general binary tree. 
 And well, what are
the other parameters? 
 So that does not look too bad. 
 It's logarithmic in answer. 
 That sounds pretty good. 
 What about the switch sizes? 
 Well, how do I measure those? 
 It's like the number of
inputs that get into it 
 and the number of
outputs that get out. 
 So in this case, I will
have 1, 2 inputs that 
 go into this switch and there
are two outputs coming out. 
 So this is what we call
a two times two switch. 
 So this will be a
two times two switch. 
 But if you look at
this one, for example, 
 we see one, two, three outgoing
edges and three ingoing edges. 
 So this is actually a
three times three switch. 
 And in a general
binary tree, we will 
 see that all these intermediate
nodes over here, they 
 are all three times
three switches. 
 So approximately
half of the switches 
 are actually three
times three switches. 
 So that's the switch size. 
 Now, you may say,
well, why don't I 
 use a larger-sized switch? 
 That would help me a lot, right? 
 If I could use, say, a four
times four switch, then 
 I would be able to have
more inputs coming in, 
 more outputs coming
out, and I can actually 
 maybe use a ternary tree
rather than a binary tree. 
 In a binary tree,
every note at the level 
 has two children, right? 
 But we could design
a tree that has 
 at every level three children. 
 So then, they can use
four times four switches. 
 But if you do that, then
the path from the leaf 
 up to the root is
getting shorter 
 and the diameter gets smaller. 
 So if I increase the
switch size-- so rather 
 than three times three,
we look at four times 
 four or five times five, six
times six and so on-- then 
 the diameter will
actually reduce. 
 So what about having a monster
switch, like I have just one 
 switch and I have my
input zero all the way up 
 to input n minus 1 and
then I have my outputs 
 on the other side? 
 Well, of course, the
switch size is n times n 
 but the diameter
is nothing, right? 
 The diameter is reduced to one. 
 You can immediately go
from an input to an output 
 through the switch. 
 But this, of course,
conceals the problem. 
 So what we are interested
in is, well, we're 
 actually really
interested in how 
 to solve the problem of
routing all these inputs 
 to these outputs using
smaller switches of size three 
 times three or two times two. 
 What we're really
interested in is, 
 what is the internal structure
in this monster switch? 
 I sort of have concealed the
problem by just saying, oh, 
 I've got a big switch. 
 But what we want
to solve today is 
 how do we do the routing in this
case within the monster switch? 
 So we want to use just
small switch sizes 
 and build up a network
using these smaller ones, 
 like three times three switches
or two times two switches. 
 Now, so that brings us
to yet another parameter, 
 because here, we'd like to
count the number or smaller 
 switches that we
use and that relates 
 to the cost of the network,
the amount of hardware 
 that you need to put into it. 
 So in this example, we
have the switch count. 
 Well, it's pretty simple, right? 
 It's 1, 2, 3, 4, 5, 6, 7--
we have seven switches. 
 And in general, if we
have n inputs-- so 1, 
 2, 3, 4 inputs-- then
the number of switches 
 that we use in the binary
tree is 2 times the number 
 of inputs minus 1. 
 So let's write that down. 
 So over here, we would
have 2 times n minus 1, 
 which is the number of
switches that you actually use. 
 So how can you
see that actually? 
 So in general, we have 1 plus 2
plus 4 plus 8 and so on plus n. 
 And it's a power of 2,
according to our assumptions. 
 And if you add them all
up, I think you'll-- well, 
 you can check for yourself that
this is actually equal to 2 
 times n minus 1. 
 So now, we have the switches. 
 So so far, this looks
pretty good, actually. 
 We use small switch sizes. 
 The number of switches
is linear in n. 
 The diameter is logarithmic
in n so that sounds good. 
 So what about congestion? 
 Do you any idea-- what's
the problem with this graph? 
 What is the big,
big problem here? 
 What can happen in a very
sort of worst-case scenario 
 where the packets get routed
from inputs to the outputs? 
 If they need to go
to certain locations, 
 then they all may have to
travel through the root. 
 So you get congestion over here. 
 We don't like that. 
 So this root is actually
then overloaded. 
 Actually, you can
already see that say, 
 this particular switch-- if this
switch fails, then actually, 
 we will have two disjoint trees
that cannot even communicate 
 to one another. 
 So this brings us to
the idea of congestion. 
 And in order to
define it better, 
 you will need a few definitions. 
 So to start, we will
define a permutation 
 and we will use this to
stipulate the requirement 
 that we want on how inputs
and outputs are related 
 to another, which input needs
to communicate to which output. 
 So permutation is a function
pi from the set 0 to n minus 1 
 to the same set. 
 And it is such
that no two numbers 
 are mapped to more than once. 
 So no two numbers are
mapped to the same value. 
 So what we really want--
to put it in mathematics, 
 we want that pi of i is
only equal to pi of j 
 if and only if i is equal to j. 
 So let's have an example to plug
into that picture over there. 
 So a first example could be
pi of i equals, say, n minus 1 
 minus i. 
 This is a proper permutation. 
 No two numbers map
to the same value. 
 Another one could be the
identity permutation, 
 like you map i to the same i. 
 So that's another example. 
 Now, how do we use
permutations to go 
 towards the idea of congestion? 
 So permutation can be used
to formulate the permutation 
 routing problem. 
 And the permutation routing
problem is defined like this. 
 It's defined as follows. 
 What we want is
that for each i, we 
 want to direct the packet at
input i to output pi of i. 
 So you want to do
that for all i. 
 So let's have a look at this
particular example, where we 
 look at identity permutation. 
 So if you do that, we can
easily route this, right? 
 So I want to send a packet
from input zero to output zero. 
 So I can simply go
into this direction. 
 I just go towards
this switch and it 
 gets routed back to this one. 
 I can go like this and
this one can go like this 
 and this one goes like that. 
 Now, if you look at
the other permutation, 
 the picture looks
very different. 
 Now, we want to route
input zero to output three. 
 In order to do this,
I will actually 
 need to go all the way through
here and then all the way down 
 to this particular output. 
 And now, the picture gets into a
big mess because for input one, 
 we have to go to output two. 
 So for input one, well, we
go all the way like this, 
 we again go through
the root, and then 
 we go down to this
particular output. 
 And as you can see,
for input two, well, 
 we need to connect
to output one. 
 So again, we go all the way
up and we go all the way down. 
 And for this one, we will
again go all the way up and all 
 the way down to input zero. 
 So now, you can see that this
particular switch over here 
 has to serve packets
from all the inputs. 
 All the four packets
have to travel 
 through this
particular node here. 
 So this leads us to the
following definition 
 of congestion. 
 So the congestion--
oh, before we continue, 
 let me first define a path. 
 So for i, we direct a packet
at input i to output pi of i. 
 And the path that
corresponds to this route 
 is actually denoted as follows. 
 So the path taken is
denoted by P i pi i. 
 So now, we can
define the congestion 
 of a set of such paths. 
 So the congestion of the
path corresponding to P zero 
 to P pi zero and so on
and we go all the way up 
 to the n minus 1
input that needs to be 
 mapped to pi of n minus 1. 
 So the congestion is now
defined as the largest 
 number of paths that pass
through a single switch. 
 So in our example, we saw that
in the case of the blue arrows 
 here for the
identity permutation, 
 well, this switch only
needs to transmit one packet 
 and all those
actually zero packets. 
 So actually, the congestion
here is equal to 1. 
 And for this
particular permutation, 
 well, we had to direct all
the packets through the root 
 and it's the most
accessed switch. 
 And that switch has
congestion four, right? 
 So the congestion over
here is equal to 4. 
 Now, this does not look so
good because for a binary tree, 
 we always have this
vulnerable root that 
 is right here in the center
connecting the left side 
 to the right side. 
 So we can always find a
permutation-- actually, 
 this permutation over
here-- that leads 
 to this worst-case congestion. 
 So what we're interested in
is the maximum congestion, 
 which is sort of the
worst-case scenario. 
 And we'll define it as follows. 
 The maximum
congestion is actually 
 equal to the maximum
over all permutations pi. 
 So this is kind of the
worst-case routing problem 
 that I can imagine and
it may occur in practice. 
 So in the worst case, how
can I solve it the best? 
 So I want to find the
minimum of the congestion 
 of a path over here
and the minimum 
 is over these types of paths. 
 So actually, this
is our solution 
 to this routing problem. 
 We want to find the
best kind of solution 
 for this worst-case
scenario-- so 
 the minimum over all
solutions for these paths 
 So well, for this
particular tree structure, 
 this permutation is really
the worst-case scenario 
 that you can have because
every packet needs to be routed 
 through the center over here. 
 And it means that our maximum
congestion for an arbitrary 
 tree is actually equal to n. 
 So that looks really
bad, actually. 
 So we don't like this at all. 
 So let's find out where we
can do a little bit better 
 and we come to look at
the two-dimensional array 
 and see what that
would lead up to. 
 And its structure is as follows. 
 We essentially have
inputs on the left 
 and the outputs
are on the bottom 
 and they are in
a grid structure. 
 So we have input zero, input
one, input two, input three. 
 They all connect
to their terminals. 
 We have switches, four of
those, and they are all 
 connected in this grid. 
 And at the very bottom, we will
have the outputs, the output 
 terminals. 
 So this is output
zero and here, we 
 will have output one, output
two, and output three. 
 So notice that my circle
start to resemble my squares, 
 but these are all the switches
right here in the center. 
 So how does this work? 
 Well, do we have a
better parameter? 
 So let's look at it together. 
 So we need to
first of all figure 
 out what the diameter is. 
 So what's the diameter of
this particular network? 
 So what's the shortest path
between the furthest input 
 and output? 
 So if you look at
that, we can see 
 that if I go all
the way from here 
 and I go all the way
down to this corner, 
 that looks like the
largest path and I 
 need to cross all these wires. 
 And in general, for
any n, we will have 
 that the diameter is 2 times n. 
 Now, what about the switch size? 
 It looks a little
bit smaller, right? 
 Because over here, we had
three inputs coming in 
 and three outputs coming
out but over here, 
 we see that every
single switch is only 
 two inputs and two outputs. 
 So that makes the
size two times two. 
 Now, the number of switches
is pretty bad, right, 
 because we have n
squared switches. 
 So that's really horrible. 
 That's a lot. 
 We would like to do much better. 
 And what about the congestion? 
 Do you have any idea
what the congestion could 
 be in this particular case? 
 We will prove a theorem on that. 
 For any permutation,
is there a way to route 
 the inputs to the outputs in
such a way that the switches 
 get almost not congested? 
 So in the binary tree,
we had a congestion 
 of n, which is linear
in the switches. 
 But over here, we
can do much better. 
 We will show that the
congestion of an n-input array 
 is actually equal to 2. 
 So that's great. 
 So I'll prove it in
a moment, but that 
 looks really fantastic. 
 And so it's way better
than the binary tree. 
 Now, this is really not so good
and this is also much larger, 
 but still-- we will
start to think next 
 after we show this
particular property how 
 to combine these two and
see how we can come up 
 with another network that's
able to combine in some ways 
 these two properties. 
 And maybe we can find a
good solution that way. 
 It turns out we will not
immediately be able to do that. 
 We will need to
make another step 
 and come to the last network. 
 It really has good parameters. 
 So what about the theorem? 
 So if you prove this,
well, how do we start? 
 You just start with
any permutation. 
 If I want to prove something
about the congestion, 
 it's defined as the maximum
of all permutations. 
 So let's take one of them
and see what we can prove. 
 So let us define the paths
for this permutation. 
 So what we really want to do
is we take any permutation 
 and we want to find a really
good solution for the routing. 
 If that gives us a very low
congestion, we are very happy. 
 So the way to do this is well,
maybe you have an idea already. 
 So how would I route this? 
 So I want to connect
an input i, say, 1, 2, 
 output two, for example. 
 How can I do this? 
 Any suggestions? 
 So of course, I
could go any path, 
 but somehow, I want to have
some uniform structure that 
 hopefully helps me to prove that
the congestion in every switch 
 is very small. 
 So how could I think about this? 
 Well, if I make sure
that, say, a packet that 
 goes from one to
output two is only 
 going to be participating
in the wires 
 off the i-th throw
and the P-i-th column, 
 then I know that every wire will
only get traveled over twice 
 by a packet. 
 This could either be a packet
that goes into this direction 
 or-- so a switch will be
accessed at most twice. 
 A switch can either receive
a packet from this direction 
 or receive a packet
from the upper part. 
 So that will be a
really good idea. 
 So let's define that. 
 So we say that in our solution,
we will design it such 
 that the path from
input i is actually 
 going to be rightward
to column pi i 
 and then downward to the
output-- so downward to output 
 by i. 
 So this is a really good
solution to the routing problem 
 because now, we can continue
our proof as follows. 
 We just say, well, if you
look at the switch in row i 
 and column pi i, well,
this one actually 
 transmits at most two packets
because a packet can only 
 come from the left or it's
going to go from the top. 
 So either one of the two--
at most, those two packets 
 will go through the switch. 
 So this shows that we have
a congestion of at most two 
 for any permutation. 
 And in order to prove
equality, because that's really 
 what the theorem
says, we also have 
 to show that there
exists a permutation that 
 achieves a congestion of two. 
 And that is pretty
straightforward. 
 We can, for example use
a specific permutation 
 that maps zero to zero and
maps n minus 1 to n minus 1. 
 Well, for this
particular permutation, 
 when we look at the
picture over here, 
 we see that input zero
needs to go to output zero. 
 We also see that this
lowest input, input three, 
 needs to travel all
the way up to here. 
 But it's clear that the packet
that needs to go over here 
 needs to travel through that
switch in the lower left bottom 
 corner. 
 And the input three also
needs to travel through that. 
 So here, we clearly see that we
you have a congestion of two. 
 So now, the proof is
complete because we 
 have shown this upper bound. 
 So for any permutation, the
congestion is at most two 
 and we see that this
specific permutation achieves 
 this congestion. 
 So this is the
end of this proof. 
 So that's great. 
 So now, what we'd
like to do is we'd 
 like to combine
these two networks 
 and see what we can
learn from both. 
 So now, we'll be taking out
a lot of chalk over here. 
 So the idea is to construct
a butterfly network 
 and I will draw it in
such a way that you can 
 see the recursive structure. 
 The idea is to do
the following thing. 
 So let me see how I
can do this the best. 
 So I will just do the top line
first and I have the spacing. 
 So we have input zero, a
terminal, we have a switch, 
 we have a switch, we have
a switch, and another one, 
 and here, we have
the output zero. 
 So the whole idea
is that I'm going 
 to combine every two outputs
by using a small butterfly 
 structure. 
 So we have two, output three,
output four-- actually, 
 I need a little bit more space. 
 Do it once more, output
one, two, three, four, five, 
 six, and a last one, seven. 
 This is going to be
pretty tight on the board. 
 So what's happening is this. 
 So these are all connected,
of course, to switches. 
 The switches output those. 
 And the idea is that we create
the following structure. 
 This switch can either
forward it over here 
 or it can cross it over
to this particular line. 
 And this switch can either
forward it or cross it over 
 to this line. 
 So this is a very small
butterfly structure. 
 Here, we have two
inputs and two outputs. 
 And we will repeat this
process and we'll do the same 
 on each of these other levels. 
 So we forward those or
we cross them, like this. 
 And now that we have constructed
all these smaller butterfly 
 structures, we can start
to combine two butterfly 
 structures together
in the bigger one. 
 So here, we had two
outputs that we combined 
 in a butterfly structure. 
 Now, we use two
butterfly structures 
 that we put into
a bigger version. 
 So how do we do this? 
 Well, we have that the
upper half over here 
 can either forward those
packets or cross them over 
 to the bottom part
butterfly structure. 
 So for these, we can either
forward them straight on 
 or we can go to
the top butterfly. 
 So you see that these two
inputs, these two switches, 
 either can forward packets
to this sub-butterfly network 
 or to the top butterfly network. 
 Now, we'll continue this
process and for these, you'll 
 do the same. 
 So we can either go
straight or we go down. 
 And over here, we
can go straight 
 or we can go to the
top butterfly network. 
 Well, now we have the final part
where we combine essentially 
 these two butterfly networks. 
 We have two butterfly networks
created here now composed again 
 of smaller ones
and these two are 
 being composed to this
bigger butterfly network. 
 Again, we take
these four switches. 
 They can route their
packets forward 
 to the top butterfly sub-network
or to the bottom one. 
 So they can either
go straight ahead 
 or this one can connect
to the first over here, 
 this one to the second, to the
third, and this to the fourth. 
 And in the same style, these can
forward them straight like this 
 and then go up like this. 
 And these are all connected
because in this example, 
 let's just have an
eight by eight network, 
 butterfly network. 
 We have input zero to seven. 
 So this is the
butterfly network. 
 In a way, what you
can see here is 
 you can see sort of the
two-dimensional structure, 
 like we have rows and columns. 
 At the same time, we can also
see this binary sort of tree 
 feeling we get from it, which
is that a switch can forward 
 sort of its packets to
either, say, the top butterfly 
 or the bottom butterfly. 
 So there's a split in two. 
 The same for this one, right? 
 This one goes either to
this butterfly network 
 or it goes to this
butterfly network. 
 So you have this tree
structure sort of 
 embedded in this
two-dimensional structure. 
 So what are the
properties of this one? 
 So let me first define in
more formal mathematics 
 how the switches
route their packets, 
 so how the connections are. 
 So in order to do that, we are
going to label each switch. 
 And the idea is that we're
going to label it by its row 
 and by its column. 
 So we will have--
the columns are 
 numbered by level zero, level
one, level two, level three, 
 yes? 
 And the rows are
these integers, but we 
 are going to represent
them by binary numbers. 
 So zero would be 000, 001,
010, 011-- oops-- 100, 101, 
 and then we got 110 and 111. 
 So for example, this particular
switch would be labeled 
 by these three bits, 001,
and the integer number, 1. 
 This one would be 011 and its
column is indexed by integer 2. 
 So a switch is
uniquely identified 
 by its row and column. 
 We will have b1
up to b logarithm 
 of n, which are
the number of bits 
 to represent the row in
digits, and to finally 
 have an integer l and this
we will call the level. 
 So this particular switch either
directs or routes a packet 
 to the switch that is
indexed by b one up to-- 
 and then we get b, l plus 1
and we take its complement. 
 So instead of if b,
l plus n would be 1, 
 we would have a 0 here. 
 If it would be a 0, we
will have a 1 over here. 
 But we repeat all the other
bits and we get to b log n. 
 And it routes us back
to the next level. 
 So we will have l plus 1. 
 Another possibility because
there are two outgoing edges 
 is if we have just b1 and
we just copy b, l plus 1, 
 essentially. 
 We route a packet
straightforward. 
 We don't do anything special. 
 We get b log n over here
and then to the next level. 
 So for example, let's see where
we can see how this works. 
 So for example, take
this particular switch. 
 We have 010. 
 So it can either go straight
on to the next level. 
 It would go to 010 but
then instead of level one, 
 we have level two, which is
the right edge over there. 
 The other one is if
this one goes up, well, 
 we will need to switch the
first bit over here, a 1. 
 We swap it into 0 and then we
go to the three zeros over here 
 and we go to the
next level and that 
 would be this particular rule. 
 So what we can do here is
to-- so when we see this, 
 we can start to figure out
how we can direct inputs 
 to outputs. 
 So let's do this. 
 So suppose I want to route a
packet from a certain input, 
 one of these, all the way to
one of the outputs over here. 
 So the way to do
this is as follows. 
 We can just start-- for example,
I want to go from switch x1 
 up to x log n comma 0. 
 So I start completely
at the left over here 
 and I want to go somewhere
of my choice to the right. 
 So I want to somehow move all
the way to some other row, y1 
 indexed by y by the bit
pattern, y1 up to y log n, 
 but now at the very last
level, which is log n. 
 Well, how do I do it? 
 Well, this switch, I can
use that rule up there 
 and simply change x1 to y1. 
 I can either leave x1 as it
is if it's the same as y1 
 or I can swap it
to its complement 
 if that's the value of y1. 
 So what I can do is I can
just simply route it to y1. 
 And then, I leave all
the other bits the same, 
 which are x2, x3, all
the way up to x log n. 
 And we will have
reached the first level. 
 Now, this one can go
to-- well, now I'm 
 going to swap the second bit
into the bit of my choice. 
 So I leave all the other
bits the same, y1 the same, 
 x3, all the others the same. 
 I just swap x2 into y2. 
 So we leave all those equal
and we go to the second level. 
 And then, we go all the
way to the final level 
 and we one by one
swap all these bits. 
 So let's have an example. 
 Suppose I want to
connect, let's say, 
 this one to for
example, well, let's say 
 this particular output. 
 So what's the
binary for this one? 
 This is actually 101. 
 So if the first bit is
different, I need to cross. 
 And otherwise, I need
to pass straight on. 
 So let's do this. 
 So over here, I'm in 011. 
 I need to go to 101 so we need
to change the zero into a one. 
 So I need to go down. 
 I need to cross. 
 Now, if I look at
the second bit, 
 I also need to change
it to a zero so again, 
 I need to cross,
which is over here. 
 Now, the third bit is equal
to 1 and it's the same. 
 So now, I can go straight ahead. 
 I do not cross and I
end up at this output. 
 So what did I do? 
 For every bit that
is different, I cross 
 and for the bits that are the
same, I go straight ahead. 
 So this is how I can route
packets from one input 
 to another output. 
 So let's look at the parameters. 
 First of all, if you
look at the diameter, 
 well, it turns out that
that's approximately 
 equal to the number of levels,
which is the logarithm of n. 
 And to be precise, it's
actually equal to 2 
 plus the logarithm of n. 
 So that's great. 
 That's a good scaling. 
 Again, it's back to
the logarithm of n. 
 So we have the best of
these two parameters. 
 The switches that we see have
two inputs and two outputs. 
 So we again have a
two times two switch. 
 The number of
switches is the number 
 of rows times the
number of columns. 
 The number of columns is the
logarithm of n and number 
 of rows is equal to n. 
 And to make it a
little bit, precise, 
 it's 1 plus the logarithm of n. 
 So that's somewhere
in between those two. 
 But if you're thinking
about it, it's 
 much better than n squared. 
 It's almost linear except
for a logarithmic factor. 
 For the congestion--
and we are not 
 going to talk about it here,
but you have a problem set 
 assignment that will
ask you to solve 
 this-- is that
actually, the congestion 
 is the square root of n or it's
equal to the square root of n 
 over 2, depending on
whether n is an even power 
 or n is an odd power. 
 Now, we're not going
to prove that here 
 because we want to step forward
to this particular network. 
 It's very exciting. 
 And you will prove this
in your problem set. 
 So this one is somewhere
in between, somewhere 
 in between these two extremes. 
 Now, it will be really
fantastic if we can somehow 
 transform this network
with a trick to, 
 again, have a really
great congestion 
 of just a constant, like two
or three or whatever or maybe 
 even one. 
 So for this particular
network, in the 1960s, 
 Benes, a Bell Labs
researcher, had the great idea 
 to use a butterfly network
and attach to it, again, 
 a butterfly network,
back to back sort of. 
 So what was his idea? 
 His idea was to
do the following. 
 So the butterfly network
as we have it right now 
 is this particular
part over here. 
 And the idea is now to start
up mixing all those outputs 
 that we got here together
again using a similar rule. 
 So what do we do? 
 We are going to
essentially repeat 
 this particular
structure on this side. 
 So how do we do it? 
 Well, we go either
straightforward 
 or we start to mix them again. 
 So it's like this output,
this particular switch, 
 can either go straight
ahead or can cross 
 to the lower part over here. 
 It goes over here and
this one goes over. 
 So as you can see, we
have repeated this part. 
 It's exactly the same as
this structure over here. 
 We'll do the same for this part. 
 So we can either cross or
we can go straight ahead. 
 Oh, we also have, of
course, that these switches 
 can go straight ahead
or can cross to the top. 
 I forgot about that. 
 So we have this--
oops-- as well. 
 So as you can see, this
particular structure 
 repeats itself
again and we slowly 
 start to build up in mixing
all the outputs again 
 or the possibility, at least,
to route them to any other row. 
 So how do we do this? 
 Well, we continue this
particular structure now 
 over here. 
 So all these can either
go straight ahead. 
 That's a possibility. 
 Or they can go all down. 
 So this switch can
either go straight ahead 
 or can go to the lower half. 
 And for these, we have
a similar structure. 
 We can either go straight ahead
or such a switch can cross over 
 to the top over here. 
 So that's this. 
 So this is Benes network and
then over here, of course, 
 we have the outputs, zero, one,
and all the way down to seven. 
 So as you can see over
here, the structure again 
 has a recursive nature to it. 
 You can see that this big
Benes network over here 
 consists of two
smaller ones that 
 are right here in the
middle, this one that 
 goes all the way up to
here-- so maybe I should 
 put a color boundary around it. 
 Let me check I want
to do this-- right. 
 So this particular
part, is again 
 a Benes network and the top
part in the same picture, 
 the top subnetwork is also
a Benes network, this part. 
 And if you look
within those, we again 
 see a top part
and a bottom part. 
 And over here, we see a top
part and also a bottom part. 
 So you see this recursive
nature again reappearing. 
 It turns out that
with this trick, 
 we can completely
eliminate congestion 
 and we can get it to only one,
which is really surprising. 
 And that what we're
going to prove here. 
 So this is a great
invention at the time. 
 It's really, really beautiful. 
 So let me put in the
other parameters. 
 So they stay
approximately the same 
 up to that the diameter
is about twice as 
 large because we added another
sort of whole butterfly 
 structure to it. 
 The switch size stays the same. 
 We, again, have about
two times more switches 
 so they sort of stay about the
same up to a linear factor, 
 like a constant factor. 
 And the congestion, however,
completely dropped down to one. 
 So that's what we're
going to prove now. 
 And in order to
get some intuition, 
 well, let me first
write down the theorem. 
 Actually, let me
put this over here. 
 So in order to get
some insight into this, 
 we are going to use
this recursive nature. 
 So we're going to use
induction and we're 
 going to say, oh,
for any permutation, 
 I can find really good routing
for say, this red subnetwork 
 and for this blue subnetwork. 
 So I know that. 
 So what I need to do is, if I
have my bigger Benes network, 
 like this one, I would
need to somehow map 
 these inputs-- I
need to route them 
 to either the top and the bottom
subnetwork, one of the two, 
 in such a way that
there will be absolutely 
 no congestion, because
we want to keep this one. 
 So a switch should only
see one packet coming in. 
 So that means, for example--
and we'll come back to that-- 
 that for example,
for this switch, 
 it should not receive a
packet from both this input 
 and from this input. 
 So the intuition that
we are going to create 
 is we're going to list our
constraints, the constraints 
 that we need to satisfy, like
the zero and the fourth input 
 should not both be mapped to
this top subnetwork and so on. 
 So we will get into
that and then we 
 will gain a lot of intuition
on how to solve this. 
 So what's the theorem? 
 So the theorem is that the
congestion of the n-input Benes 
 network is actually equal to 1. 
 And we will prove this for
n equal to a power of 2. 
 We have assumed
that at the start 
 that we had with all the
other networks, as well. 
 And in this case, we
will use induction on a. 
 So that's the
method that we will 
 do because that's also
the recursive structure 
 of the Benes network itself. 
 So we will use
induction on a and we 
 are going to define the
induction hypothesis simply 
 as, "The theorem is true for a." 
 Now, let us do the base case. 
 We always start
with the base case 
 and that should be pretty
easy because this is 
 the most basic Benes network. 
 So n equals 2 to the power of 1. 
 We essentially have two inputs,
an input zero and an input one. 
 They are connected to these
switches over here that 
 can either forward them
or can cross them over 
 and then they go
directly to the output. 
 Notice that in
this case, we just 
 have the most elementary
butterfly network. 
 It's the same. 
 So we have output
zero and output one. 
 So this corresponds
in this picture 
 to these little small
things over here, 
 this one and this one
and this one over here 
 and the fourth one over here. 
 So now, let's take
any permutation. 
 We want to show that we
can route it in such a way 
 that there's only a
congestion of one. 
 So let's do this. 
 So there are essentially
only two permutations. 
 Either zero is mapped
to zero and one 
 is mapped to one or
zero is mapped to one 
 and one is mapped to zero. 
 So in both cases, we
can just route them 
 through their own switches. 
 So we have that either pi
of 0 equals 0 and pi of 1 
 equals 1, in which case we just
direct them straight through 
 and we go straight through
and every switch only 
 sees a packet once. 
 So for this particular
permutation, 
 we have a congestion of one. 
 Now, the other permutation
that we can have 
 is if zero is mapped to one
and if one is mapped to zero. 
 Well, in that
case, we just route 
 this cross over
to the bottom row 
 and here we go from this
switch to the top row. 
 Again, every switch
only sees a packet once. 
 So in this case, in the
base case, we are done. 
 We are happy. 
 We have shown that the
congestion is equal to one. 
 So now, it gets
to the harder part 
 because for the
inductive step, we 
 are going to assume,
of course, that it 
 holds true for a
smaller Benes network. 
 So we assume that P a
is true and well, let's 
 try to gain some insight here. 
 So we know from our
induction hypothesis, 
 within each subnetwork, we
can solve any routing problem 
 with congestion one and for
this subnetwork, the same. 
 That's our induction hypothesis. 
 So how do we go ahead? 
 We need to somehow
map these inputs 
 according to the
permutation of our choice. 
 So that could be for
some input zero goes 
 to output five or input one
goes to output two, et cetera. 
 So somehow, we need
to choose where 
 we are going to map this
particular input to. 
 So packet zero that
comes from this input 
 should either go
to the red network 
 or it should go to
the blue network. 
 And for each of these inputs,
we can make such a choice. 
 But we have to be
very smart about it 
 because we need to
avoid any congestion. 
 So the intuition
is that we're going 
 to set up a constraint graph,
a graph that represents all 
 the constraints that we
need to satisfy in order 
 to achieve congestion of one. 
 So let's do an
example so that we 
 can figure out what's going on. 
 Actually, let me
put it over here. 
 So just take an
example permutation 
 and we'll go
through this example 
 and then see how
the proof works. 
 So let's as an example
have pi of zero maps 
 to one, pi of one maps to
five, pi of two goes to four, 
 input three goes to
seven, four maps to three, 
 five to six, six to
zero, and seven to two. 
 So this is just an
arbitrary permutation. 
 So what do we see? 
 We want to make sure that, for
example, this switch is only 
 seeing one packet. 
 So it cannot see a packet both
coming from input zero as well 
 as from input four. 
 I cannot see that. 
 I do not want that to happen. 
 Similarly, for
this one, I do not 
 want to see a packet coming
from one or one from five. 
 So let me define a constraint
graph that sort of represents 
 this. 
 So the constraint graph
that we are interested in 
 is defined as follows. 
 If two packets must pass
through different networks, 
 subnetworks-- so in our case,
the red and blue subnetwork-- 
 then we'll actually have
an edge between those two. 
 So then, there is an
edge between them. 
 So for this example, we're
going to set up this constraint 
 graph. 
 So I was just talking about
this particular switch. 
 It cannot see one coming from
four and a packet from zero. 
 So what he have, we have an
edge between zero and four. 
 In the same way, we have
an edge from one to five. 
 Why? 
 Because a packet that comes
from input one and a packet that 
 comes from input five cannot
both be routed through 
 the switch because then the
switch would see two packets 
 and then the congestion would
not be one, but two, right? 
 So one and five also
have an edge in between. 
 And in the same way, we have
two and six and seven and three. 
 So two and six is this
constraint, like two and six 
 over here. 
 And three and seven is
the other constraint. 
 So if I have those constraints
in place, well then, 
 I know that the routing
that goes from level zero 
 to level one will not
violate my congestion of one. 
 So that's great. 
 Then, I hope to be able to
use the induction hypothesis 
 and I get a proper routing
within the red subnetwork 
 and one within the blue network. 
 And then, I need to map
all these to these outputs. 
 So I also have constraints
on these outputs 
 because, well, For example,
take this particular switch. 
 It should not see a packet
coming from this particular one 
 and one from this one. 
 So how do I code that up? 
 So let me first write
out what we did here 
 and then we'll do the same
for the last level over there. 
 So-- oh no, that's
not really necessary. 
 So at the output
side over here, we 
 have similar constraints
as we did over here. 
 And in this particular
example, just as an example, 
 suppose we look
at the packet that 
 is destined for output zero. 
 Well, what is this packet? 
 Well, I know that's
pi of 6 is equal to 0, 
 according to my example. 
 So packet six is destined
for this particular output 
 zero over here and goes
through this particular switch. 
 So this packet and
also the packet 
 for output four, which is if
you look at the mapping, pi of 2 
 is equal to 4. 
 So that's packet number two. 
 Well, both of these packets
cannot pass through the same 
 subnetwork. 
 So why is this? 
 So let's look at this
particular example. 
 So output zero, well,
comes from packet six, 
 somewhere over there. 
 Now suppose packet six was
routed through the red network 
 and at the same moment
also, output four-- 
 the packet that is destined
for output four, which 
 is packet number two--
suppose packet two was also 
 going through the red network. 
 Well, then I notice that
both of these packets 
 must arrive at this particular
switch in order for one 
 to be routed to output
zero and the other one 
 to be routed to output four. 
 So in order to avoid congestion
in this particular switch 
 over here, we need
to have a constraint. 
 The constraint says that the
packet for packets two and six, 
 that those two cannot go
through the same subnetwork. 
 So essentially have
another edge over here-- 
 we already had the constraint
but it's just the same edge. 
 So let's look at the other
constraints that we have. 
 Well, let's look at
a different example. 
 So for example, if I
look at this switch, 
 well, if a packet
goes through here 
 that needs to end up
at one and a packet 
 that's goes to five, if
those two packets are routed 
 through the same
red subnetwork, they 
 have to end up here in order to
go to both here and to there. 
 So we have congestion of two. 
 So what are those packets? 
 Well, what does pi map
to to one and five? 
 Let's look over here. 
 We see that pi 0 is equal
to 1 and pi 1 is equal to 5. 
 So packets zero and one are
actually mapped to output 
 one and five and
they should not go 
 both through the
same subnetwork. 
 So we have another
edge over here. 
 And now, we can continue this
and we have five and seven. 
 So just have a look over there. 
 See, five and seven, they map
to the outputs two and six. 
 Again, we have two and six. 
 If they are both mapped to
the same network, this one, 
 for example, then I
will have a problem. 
 So the other edge is over here. 
 So what did we do here? 
 We started to write out the
constraints on this side 
 and we wrote out the
constraints on this side. 
 So I only looked at
the red subnetwork. 
 That's what I realize now. 
 I could also have looked
at the blue network. 
 So let's do that also just
to make the picture complete. 
 So for example, let's look
at this particular example. 
 The packet six and
two should not both 
 be routed through
the blue network 
 because then they
would both have 
 to go through this
switch, one going up 
 to output zero and one going
to the right to output four. 
 So in order to avoid
congestion at all costs, 
 we have this constraint graph. 
 So now, we come to
the key insight. 
 And the key insight is to use
a two-coloring of this graph. 
 So the key insight
is a two-coloring 
 of the constraint
graph, which will 
 lead to a best solution
for the routing problem. 
 So let's do this. 
 So we will color this one blue. 
 As you can see, this
is an even cycle, 
 blue, red, blue, red,
and blue and red. 
 We will make this one
blue and this one red. 
 Well, it turns out that we can
now start our routing process. 
 So for example, actually,
I will draw a new graph 
 to make that really clear. 
 So I have my blue and
my red chalk over here 
 to demonstrate what I mean. 
 So what do I do? 
 I have zero, one, two, three,
four, five, six, and seven. 
 I have the switches that
correspond to those. 
 Well, if it's colored red-- so
zero over here is colored red-- 
 I will direct it to
the red subnetwork. 
 So where is this red subnetwork? 
 It's really contained over
here and the blue one-- 
 so this is the red one and
the blue one is right here. 
 And over here, we have the
outputs ranging from zero, one, 
 two, all the way to seven. 
 So input zero is colored red. 
 We go straight ahead. 
 We want to go to
the red network. 
 Input one is colored blue. 
 It goes, therefore,
to the blue network. 
 So this is the only
way how to do it. 
 Input two is colored red. 
 Go straight ahead. 
 Input three is also colored red. 
 Go straight ahead. 
 Input five-- oh, input
four is colored blue-- 
 goes to the blue network. 
 Input five goes up
to the red network 
 and input six goes straight
ahead to the blue network. 
 It's colored blue and input
seven is also colored blue. 
 Let's look at the outputs. 
 So for example, well, let's
have a look at output zero. 
 so output zero-- which packet
is mapped to output zero? 
 It's packet number six. 
 So six was mapped
into the blue network 
 and then it needs to be
mapped to output zero. 
 So there's only
one edge that goes 
 from the blue network
to output zero, which 
 is this particular one. 
 And then somehow,
this one needs to be 
 mapped to this one over here. 
 Now, we can continue like this. 
 Output one should receives
a packet from-- let's look 
 at the permutation-- from five. 
 No, sorry, output one--
pi of 0 is equal to 1 
 so packet zero needs to go
to this particular output. 
 Now, packet zero is
in the red network 
 so there's only one edge that
goes from the red network 
 to this output. 
 So we need to have a
connection over here. 
 Now, we can continue this
and note and demonstrate-- 
 and you can test
it for yourself, 
 too-- that output
four needs to receive 
 a packet from the red network. 
 Actually, it should be this
particular one, which happens 
 to be packet number two. 
 And then, we have
this one, right? 
 So let me just finish it. 
 We have this and we have these
two and we have this one. 
 We have this one and
we have this one. 
 This one goes straight ahead. 
 This one goes all the way up and
this one goes all the way up. 
 So what do we see? 
 We see that packets over
here, that these switches only 
 see a packet once
and these ones, 
 as well, these ones also
and these ones also. 
 So we have directed the
packets, routed the packets 
 to the red and the blue
subnetworks in such a way 
 that the congestion at the last
level and at the first level 
 is still equal to one. 
 Now, we use our
induction hypothesis 
 and we conclude that we
can map the route that's 
 going to have a routing
from packets from here 
 to here such that the congestion
within the subnetworks 
 is only one, so within the
blue as well as in the red. 
 So this is the insight into
how this works and I notice 
 I am running out of time. 
 So the formal proof we will have
to postpone until recitation, 
 but that's actually
really a very simple thing 
 to do that right now. 
 So just keep this
key insight and then 
 you can easily
prove the theorem. 
 But this is the real insight. 
 Thank you. 

